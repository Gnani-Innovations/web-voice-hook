import AudioMotionAnalyzer from"audiomotion-analyzer";import{useCallback,useMemo,useRef,useState}from"react";import{audioProcessorSource}from"./audioProcessorSource.generated";import{applyCustomColor,base64ToPCM16Data,convertPCMDataToFloat32,getBase64Audio,getVisualizerOptions,resampleAudio,resetAudioInput}from"./webVoiceUtils";const SAMPLE_RATE=44100;export const CHANNELS=1;export const BITS_PER_SAMPLE=16;const defaultLogger={info:(e,...r)=>console.log("[GnaniWebVoice]",e,...r),error:(e,...r)=>console.error("[GnaniWebVoice]",e,...r)};export const useWebSocketAudio=({websocketUrl:e,workletPath:r,visualizerOptions:{elementId:t,color:n,options:c}={},events:u,logger:o})=>{const{onOpen:a,onClose:s,onException:l}=u??{},i=o??defaultLogger,[d,p]=useState(!1),f=useRef(null),g=useRef(null),m=useRef(null),y=useRef([]),S=useRef(!1),v=useRef(!0),h=useRef(),b=useRef(!1),k=useRef(!1),C=useRef(44100),R=useRef(!1),E=useRef(!1),O=useRef(0),w=useRef(0),N=useRef(0),P=useRef(null),I=useRef(null),[T,A]=useState(!1),L=useRef(!1),M=44100,W=useRef([]),D=useRef(null),J=useCallback(()=>(g.current&&"closed"!==g.current.state||(g.current=new(window.AudioContext||window.webkitAudioContext)({sampleRate:44100,latencyHint:"playback"})),g.current),[]),_=useCallback(e=>{if(!t||P.current||k.current)P.current?.connectInput(e);else{const r=new AudioMotionAnalyzer(document.getElementById(t),{...c??getVisualizerOptions(e)});r.start(),n&&applyCustomColor(r,n),P.current=r}},[]),x=useCallback(async()=>{if(!b.current){resetAudioInput(h.current);try{h.current=await navigator.mediaDevices.getUserMedia({audio:{sampleRate:44100,channelCount:1,echoCancellation:{ideal:!0},noiseSuppression:{ideal:!0},autoGainControl:{ideal:!0}}});const e=J(),r=e.createMediaStreamSource(h.current),t=e.createDynamicsCompressor();t.threshold.value=-30,t.knee.value=40,t.ratio.value=8,t.attack.value=.002,t.release.value=.1;const n=e.createGain();n.gain.value=1.2,r.connect(t).connect(n),_(r),b.current=!0}catch(e){throw i.error("Error setting up audio stream:",e),l?.(e),e}}},[J,_]),{startProcessing:B,stopProcessing:G,isProcessing:U}=useMemo(()=>{let e=null,t=null;return{startProcessing:async()=>{if(h.current)try{const n=J(),c=void 0===r||""===r,u=c?URL.createObjectURL(new Blob([audioProcessorSource],{type:"application/javascript"})):r;try{await n.audioWorklet.addModule(u)}finally{c&&URL.revokeObjectURL(u)}t=n.createMediaStreamSource(h.current),e=new AudioWorkletNode(n,"audio-processor",{numberOfInputs:1,numberOfOutputs:1,channelCount:1,processorOptions:{sampleRate:n.sampleRate}}),e.port.onmessage=e=>{if(f.current?.readyState===WebSocket.OPEN){const{data:r,timestamp:t}=e.data,n=getBase64Audio(r);f.current.send(JSON.stringify({event:"media",media:{payload:n,timestamp:t}}))}},t.connect(e)}catch(e){i.error("Failed to start audio processing:",e),l?.(e)}},stopProcessing:()=>{e&&(e.disconnect(),e=null),t&&(t.disconnect(),t=null)},isProcessing:!!e}},[J,r]),z=useCallback(e=>{J();try{const r=base64ToPCM16Data(e),t=convertPCMDataToFloat32(r),n=44100===C.current?t:resampleAudio(t,C.current,44100);W.current.push(n);const c=W.current.reduce((e,r)=>e+r.length,0);c>=(v.current?6615:M)||L.current||R.current&&c>0?F():D.current||(D.current=setTimeout(()=>{D.current=null,W.current.length>0&&F()},500))}catch(e){i.error("Error processing audio chunk:",e)}},[J]),F=useCallback(()=>{const e=J();if(!e)return;D.current&&(clearTimeout(D.current),D.current=null);let r=W.current.reduce((e,r)=>e+r.length,0);const t=v.current?6615:M,n=R.current&&r>0;if(!L.current&&r<t&&!n)D.current||(D.current=setTimeout(()=>{D.current=null,W.current.length>0&&F()},500));else for(;W.current.length>0&&(n||L.current||!(r<t));){let t=0;const n=[];for(;W.current.length>0&&t<M;){const e=W.current.shift();n.push(e),t+=e.length}if(0===t)break;const c=new Float32Array(t);let u=0;for(const e of n)c.set(e,u),u+=e.length;const o=e.createBuffer(1,c.length,44100);o.getChannelData(0).set(c);const a=e.createBufferSource();a.buffer=o,a.connect(e.destination),y.current.push(a),_(a);const s=.02,l=Math.max(e.currentTime+s,w.current||0);E.current||(f.current?.send(JSON.stringify({event:"TTS_PLAYING",media:{tts_playing:!0}})),E.current=!0),L.current=!0,p(!0),N.current+=1,a.onended=()=>{y.current=y.current.filter(e=>e!==a),N.current=Math.max(0,N.current-1),0===N.current&&0===W.current.length&&(L.current=!1,p(!1),f.current?.send(JSON.stringify({event:"TTS_PLAYING",media:{tts_playing:!1}})),E.current=!1,R.current&&f.current?.close())},a.start(l),w.current=l+o.duration,m.current=a,S.current=!0,v.current=!1,r-=t}},[J,_]),V=useCallback(()=>{if(P.current){try{P.current.stop()}catch{}try{P.current.destroy()}catch(e){i.error("Failed to destroy analyzer:",e)}finally{P.current=null}}},[]),j=useCallback(()=>{D.current&&(clearTimeout(D.current),D.current=null),W.current=[],w.current=0,N.current=0,L.current=!1,S.current=!1,p(!1),y.current.forEach(e=>{try{e.stop()}catch{}e.disconnect()}),y.current=[],m.current=null,E.current&&(f.current?.send(JSON.stringify({event:"TTS_PLAYING",media:{tts_playing:!1}})),E.current=!1)},[]),Y=useCallback(async e=>{try{"media"===e.event&&e.media?.payload?(0===O.current&&(O.current=Date.now(),i.info("Chunk received at:",O.current)),C.current=e.sample_rate??44100,z(e.media.payload)):["barge","BARGE"].includes(e.event)?(i.info("Barged"),j()):"EOC"===e.event?(i.info("EOC event occurred"),f.current?.send(JSON.stringify({event:"EOC"}))):"stop"===e.event?(i.info("Stop event occurred"),f.current?.readyState===WebSocket.OPEN&&(R.current=!0),W.current.length>0&&F()):i.info("Unhandled message type:",e)}catch(e){i.error("Error processing audio message:",e)}},[F,z,j]),H=useCallback(e=>{if(!k.current){if(k.current=!0,G(),I.current&&(clearInterval(I.current),I.current=null),f.current&&(f.current.readyState!==WebSocket.OPEN&&f.current.readyState!==WebSocket.CONNECTING||f.current.close(),f.current=null),V(),g.current&&(g.current.close(),g.current=null),m.current&&(m.current.stop(),m.current.disconnect(),m.current=null),y.current.length>0&&(y.current.forEach(e=>{try{e.stop()}catch{}e.disconnect()}),y.current=[]),h.current){h.current.getTracks().forEach(e=>{e.stop(),e.enabled=!1,h.current?.removeTrack(e)}),h.current=void 0}D.current&&(clearTimeout(D.current),D.current=null),W.current=[],S.current=!1,b.current=!1,v.current=!0,L.current=!1,R.current=!1,w.current=0,N.current=0,p(!1),A(!1),s?.(e)}},[G,s,V]),K=useCallback(()=>{if(!e||f.current||k.current||T)return;k.current=!1,v.current=!0;const r=new WebSocket(e);f.current=r,r.onopen=async()=>{k.current?r.close():(A(!0),f.current?.send(JSON.stringify({event:"ping",metadata:{timestamp:Date.now().toString()}})),I.current&&(clearInterval(I.current),I.current=null),I.current=setInterval(()=>{k.current||f.current?.readyState!==WebSocket.OPEN?I.current&&(clearInterval(I.current),I.current=null):f.current?.send(JSON.stringify({event:"ping",metadata:{timestamp:Date.now().toString()}}))},1e4),await x(),await B(),r.send(JSON.stringify({event:"start"})))},r.onmessage=e=>{if(!k.current)try{const r=JSON.parse(e.data);r&&Y(r)}catch(e){i.error("Error parsing websocket message:",e)}},r.onclose=e=>{I.current&&(clearInterval(I.current),I.current=null);"LINK_EXPIRED"===e.reason&&(i.info("Link expired"),location.reload()),k.current||H("server"),G()},r.onerror=e=>{i.error("WebSocket error:",e),l?.(e),k.current||H("server")}},[e,a,s,l,x,B,T]),X=useCallback(()=>{H("client")},[H]),q=useCallback(r=>{if(f.current&&(f.current.close(),f.current=null),k.current=!1,v.current=!0,S.current=!1,b.current=!1,L.current=!1,R.current=!1,w.current=0,N.current=0,A(!1),p(!1),D.current&&(clearTimeout(D.current),D.current=null),W.current=[],g.current&&(g.current.close(),g.current=null),m.current&&(m.current.stop(),m.current.disconnect(),m.current=null),y.current.length>0&&(y.current.forEach(e=>{try{e.stop()}catch{}e.disconnect()}),y.current=[]),V(),h.current){h.current.getTracks().forEach(e=>{e.stop(),e.enabled=!1,h.current?.removeTrack(e)}),h.current=void 0}if(G(),!e)return void i.error("Cannot reconnect: websocketUrl is required");const t=new WebSocket(e);f.current=t,t.onopen=async()=>{k.current?t.close():(A(!0),I.current&&(clearInterval(I.current),I.current=null),I.current=setInterval(()=>{k.current||f.current?.readyState!==WebSocket.OPEN?I.current&&(clearInterval(I.current),I.current=null):f.current?.send(JSON.stringify({event:"ping",metadata:{timestamp:Date.now().toString()}}))},1e4),await x(),await B(),t.send(JSON.stringify({event:"start"})),r?.())},t.onmessage=e=>{if(!k.current)try{const r=JSON.parse(e.data);r&&Y(r)}catch(e){i.error("Error parsing websocket message:",e),l?.(e)}},t.onclose=e=>{I.current&&(clearInterval(I.current),I.current=null);"LINK_EXPIRED"===e.reason&&(i.info("Link expired"),location.reload()),k.current||H("server"),G()},t.onerror=e=>{i.error("WebSocket error:",e),l?.(e),k.current||H("server")}},[e,a,s,l,x,B,G,H,V]);return{isConnected:T,isPlaying:d,startRecording:B,stopRecording:G,isRecording:U,connect:K,disconnect:X,reconnect:q}};
//# sourceMappingURL=useWebVoice.js.map